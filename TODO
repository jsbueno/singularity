DONE

Done:

1. field descriptor/data_classes
3. specialize data types
4. namespace acessor  for dotted attributes
5. JSON export
6. reactive fields
7. JSON import
8.Field value deleting
9. copy, deepcopy and pickling work
10. Use of dataclasses as fields
11. .nested field access as mapping keys
12. refactor main file
13. mapping-like access for dotted attributes
14. enable field-class-autoreference (and therefore graph database possibilities)
15. Field handling of default values

TODO

. Add an "id" UUID to all objects

. Fields can be rich objects themselves (not just typefields) - with a main 'value' to get bound-fields value
. EdgeField - for 2 way object linking
. Field handling of mandatory values
. Field validators and options - including "back reference" for simple nx1 linking.
. StringField Lenght parameters
. postgresql jsonb persistence (using SQLAlchemy for connections)
. declarative data classes - for nested fields buildable in one line
. postgresql JSONB persistence and indexing
. file-based persistence (use uuid's for filenames, rely on OS filesystem code for indexing)
. cryptografy layer for the persistence
. Schema JSON import/export
. workflow-states
. workflow-permissions
. workflow history tracking
. data history and versioning for items
. Concept of "contexts" - object that will tell singularity configuration such as which backend and connection settings use for data persistence and queries, where are users and roles fetched from - equivalent to "connections" on Python SQL drivers.

. Python code generation from Schema.
. Django-model dynamic generation
. SQLAlchemy-model dynamic generation
. Colander/DjangoForms dynamic generation
. automatic model change and versioning tracking (integrated with git)
. Captain'Proto interoperation
. Data Instances UUID should persists across backends/serialization/desserialization/differing systems/different nodes.



Implementation Details TODO:

.inter-references on the data mechanisms should use weakrefs
. Refactor to distinct files
. publish on pypi

cooking right now:

    uuid "id" field for all classes
    make "m" class binding use the instance id instead of a new instance of self
    make fields bindable using the same mechanism "m" class uses
    allow rich fields that are themselves object-data classes + default "value" attribute for bound fields
    implement EdgeField that allows object reciprocal linking

